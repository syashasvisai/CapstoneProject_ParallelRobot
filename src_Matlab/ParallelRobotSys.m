classdef ParallelRobotSys
    % PARALLELROBOTSYS -  A class that models a planar 2RPR parallel robot
    % The trajectory of this system is completely determined by initial
    % position of the rigid bodies and the target position of the platform
    % The CTRLINP method calculates the Control input u from the given
    % target coordinates and PD tuning values. The Controller is designed
    % such that it works both in the positive and negative quadrants of the
    % parallel robot
    % The DYNAMICS method returns the final position 
    % The EVOLUTION method calls the ODEPD method iteratively to evolve the
    % system over a given period of time with a given time step.
    
    properties (SetAccess = private, GetAccess = protected)
        m1, m2, m3, a;
    end 
    
    methods
        % Constructor
        function obj = ParallelRobotSys(mass1,mass2,mass3,dist_a)
            obj.m1 = mass1;
            obj.m2 = mass2;
            obj.m3 = mass3;
            obj.a = dist_a;
        end

        % Evolves the system of equations with respect to the control input
        function [t,y] = evolution(obj,x_init,t_span)
            [t,y] = ode45(@(varargin)obj.ctrl_input(varargin{:}),t_span,x_init);
        end

         % Assigns the controller to the tasks and then evolves the system
         % with the control input u generated by the controller 
         function [dy] = ctrl_input(obj,~,y)

            Kpx = 5;
            Kpy = 5;
            Kdx = 3;
            Kdy = 3;

            % Forward Kinematics to calculate current position of Platform (x,y)
            x_curr = y(1)*cos(y(5))- obj.a/2;
            y_curr = y(1)*sin(y(5));

            % for efficient error vector(k) calculation. The derivatives need to be
            % calculated through numerical difference methods
            xDot_curr = y(2)*cos(y(5))-y(1)*y(6)*sin(y(5));
            yDot_curr = y(2)*sin(y(5))+y(1)*y(6)*cos(y(5));

            %Task Space Controller
            S = [cos(y(5))   , sin(y(5));
                cos(y(7))   , sin(y(7))];

            if y(10) >= 0 && y_curr >=0 
                u = pinv(S')*[Kpx*(y(9)-x_curr)-Kdx*xDot_curr ; Kpy*(y(10) - y_curr)-Kdy*yDot_curr];
            elseif y(10) < 0 && y_curr <0 
                u = pinv(S')*[Kpx*(y(9)-x_curr)-Kdx*xDot_curr ; -(Kpy*(y(10) - y_curr)-Kdy*yDot_curr)];
            elseif y_curr>=0 && y(10) <0 
                u = pinv(S')*[+Kpx*(y(9)-x_curr)-Kdx*xDot_curr ; +Kpy*(y(10) - y_curr)+Kdy*yDot_curr];
            elseif y_curr<=0 && y(10) > 0
                u = pinv(S')*[+Kpx*(y(9)-x_curr)-Kdx*xDot_curr ; -Kpy*(y(10) - y_curr)+Kdy*yDot_curr];
            else
                u = [0 0]';
            end
       
            dy = obj.dynamics(y,u);
         end

         % Gives the dynamic relationship between variables - Equations of
         % motion

        function [dy] = dynamics(obj,y,u)
            dy1 = y(2);
            dy3 = y(4);
            dy5 = y(6);
            dy7 = y(8);
            dy2 =(4*u(1) + 4*u(2)*cos(y(5) - y(7)) + obj.m1*y(1)*y(6)^2 + obj.m2*y(1)*y(6)^2 + 4*obj.m3*y(1)*y(6)^2)/(obj.m1 + obj.m2 + 4*obj.m3);
            dy4 =(4*u(2) + 4*u(1)*cos(y(5) - y(7)) + obj.m1*y(3)*y(8)^2 + obj.m2*y(3)*y(8)^2 + 4*obj.m3*y(3)*y(8)^2)/(obj.m1 + obj.m2 + 4*obj.m3);
            dy6 =-(2*(2*u(2)*sin(y(5) - y(7)) + obj.m1*y(2)*y(6) + obj.m2*y(2)*y(6) + 4*obj.m3*y(2)*y(6)))/(y(1)*(obj.m1 + obj.m2 + 4*obj.m3));
            dy8 =-(2*(obj.m1*y(4)*y(8) - 2*u(1)*sin(y(5) - y(7)) + obj.m2*y(4)*y(8) + 4*obj.m3*y(4)*y(8)))/(y(3)*(obj.m1 + obj.m2 + 4*obj.m3));
            dy = [dy1; dy2; dy3; dy4; dy5; dy6; dy7; dy8; 0; 0]; 
        end
    end
end

